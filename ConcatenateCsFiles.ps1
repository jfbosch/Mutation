# Define variables using the current directory the script is executing from
$rootDirectory = $PSScriptRoot
$outputDirectory = $PSScriptRoot

$excludedFiles = @(
    "SampleFile1.cs",
    "SampleFile2.cs"
)  # add any filenames you want to exclude (case-insensitive)

# Normalize the excluded filenames to lowercase for consistent comparison
$excludedFiles = $excludedFiles | ForEach-Object { $_.ToLower() }

# Ensure the output directory exists
if (-not (Test-Path $outputDirectory)) {
    New-Item -ItemType Directory -Path $outputDirectory | Out-Null
}

# Get all .cs files recursively from the root directory, excluding folders and any specified filenames
$csFiles = Get-ChildItem -Path $rootDirectory -Recurse -Filter *.cs |
    Where-Object { -not $_.PSIsContainer -and ($excludedFiles -notcontains $_.Name.ToLower()) }

Write-Output "Found $($csFiles.Count) .cs files."

# Define the full path for the concatenated output file
$targetFile = Join-Path -Path $outputDirectory -ChildPath "all-cs.txt"

# Remove the target file if it already exists to avoid appending to old data
if (Test-Path $targetFile) {
    Remove-Item $targetFile
}

# Process each .cs file
foreach ($file in $csFiles) {
    # Read the entire file content as a single string
    $content = Get-Content $file.FullName -Raw

    # Skip files that contain generated code markers.
    # The -imatch operator makes the match case-insensitive.
    # This regex handles variations like:
    #   <auto-generated/>, <auto-generated />, <autogenerated/>, <autogenerated /> etc.
    if ($content -imatch "This code was generated by a tool\." -or 
        $content -imatch "<\s*auto[-\s]?generated\s*/?\s*>") {
        Write-Output "Skipping generated file: $($file.FullName)"
        continue
    }
    
    Write-Output "Processing file: $($file.FullName)"
    
    # Calculate relative path from the script folder to the file
    $relativePath = $file.FullName.Replace($rootDirectory, "").TrimStart('\', '/')
    
    # Create header comment with the relative path and a dashed separator line
    $dashes = [string]::Join('', (1..30 | ForEach-Object { '-' }))
    $header = "// $relativePath`r`n// $dashes`r`n"
    
    # Append header comment and file content to the target file
    Add-Content -Path $targetFile -Value $header
    $content | Add-Content -Path $targetFile
    # Optionally add a newline separator between files
    Add-Content -Path $targetFile -Value "`r`n"
}

Write-Host "Press any key to exit..."
[System.Console]::ReadKey() | Out-Null
